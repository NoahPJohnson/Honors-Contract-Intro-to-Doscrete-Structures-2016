/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package BplusTree;

/**
 *
 * @author Noah
 */

import java.util.ArrayList;
import java.util.Collections;

public class Node
{
 private int n = 3;
 private int firstKey;
 private ArrayList<Integer> keyList;
 private ArrayList<Integer> sortList;
 private ArrayList<Node> children;
 private ArrayList<Node> oldChildren;
 private Node sibling;
 private Node parent;
 private Node splitOne;
 private Node splitTwo;
 
 private int childCount = 0;
 private boolean root = false;

 public Node(boolean r)
 {
  keyList = new ArrayList();
  sortList = new ArrayList();
  children = new ArrayList();
  oldChildren = new ArrayList();  
  if (keyList.size() > 0)
     {
      firstKey = keyList.get(0);
     }
  parent = null;
  root = r; 
 }        
 
 public int getN()
 {
    return n;
 } 
 
 public void setParent(Node p)
 {
    parent = p;
 }
 
 public Node getParent()
 {
    return parent; 
 }        
 
 public boolean checkIfRoot()
 {
    return root;
 }     
 
 public ArrayList getKeyList()
 {
    return keyList;   
 }
 
 public int getKey(int i)
 {
    return keyList.get(i);
 }        
 
 public ArrayList<Node> getChildren()
 {
    return children;   
 }        
 
 public int getChildCount()
 {
     return childCount;
 }  
 
 public Node getChild(int i)
 {
     return children.get(i);
 }        
         
 public void setKey(int e)
 {
    keyList.add(e);
    Collections.sort(keyList);
    if (keyList.size() >= n)
       {
        split();   
       } 
 }   
 
 public void addChild()
 {
    childCount ++;
    children.add(new Node(false));
 }          
 
 public void addSpecificChild(Node c)
 {
     childCount ++;
     children.add(c);
 }        
 
 public int getFirstKey()
 {
  return firstKey;   
 }
 
 public int setFirstKey()
 {
  if (keyList.size() != 0)
     {
      firstKey = keyList.get(0);
     } 
  return firstKey;
 }    
 
 public void addRootParent()
 {
     
 }   
 
 public boolean itemSearch(int key)
 {
    if (keyList.contains(key))
       {
        return true;
       }
    else
       {
        return false; 
       } 
 }       
         
 public void split()
 {
     int mid = n/2;
     int midKey = keyList.get((n/2));
     int index = 0;
     if (checkIfRoot() == true)
        {
         if (children.size() > 0)
            { 
             System.out.print("Parent Secondary Split");
             for (int i = 0; i < children.size(); i ++)
                 {
                  oldChildren.add(children.get(i));   
                 } 
             while (children.size() != 0)
                 { 
                  children.remove(0);
                 }
             System.out.print("Children1: ");
             System.out.println(children.toString());

             splitOne = new Node(false);
             for (int i = 0; i < mid; i ++)
                 {
                  splitOne.setKey(keyList.get(i));
                  if (oldChildren.size() > 0)
                     { 
                      for (int q = 0; q < mid; q ++)
                          {
                           splitOne.children.add(oldChildren.get(q));
                          }
                     }     
                 }
             System.out.print("Children1: ");
             System.out.println(splitOne.children.toString());

             splitTwo = new Node(false);
             for (int i = mid+1; i < n; i ++)
                 {
                  splitTwo.setKey(keyList.get(i));
                  if (oldChildren.size() > 0)
                     { 
                      for (int q = mid; q < oldChildren.size()-1; q ++)
                          {
                           splitTwo.children.add(oldChildren.get(q));
                          }
                     }      
                 }
             //children.get(children.size()-2).addSpecificChild(children.get(childCount-1));
             System.out.print("Children2: ");
             System.out.println(splitTwo.children.toString());
             
             if (splitOne.setFirstKey() > splitTwo.setFirstKey())
                { 
                 addSpecificChild(splitTwo);
                 addSpecificChild(splitOne);
                } 
             else
                {
                 addSpecificChild(splitOne);
                 addSpecificChild(splitTwo);   
                } 
             while (oldChildren.size() != 0)
                 { 
                  oldChildren.remove(0);
                 }
            }
         else
            {
             System.out.println("Parent Split");
             splitOne = new Node(false);
             for (int i = 0; i < mid; i ++)
                 {
                  splitOne.setKey(keyList.get(i));
                 }

             splitTwo = new Node(false);
             for (int i = mid; i < n; i ++)
                 {
                  splitTwo.setKey(keyList.get(i));
                 }
             if (splitOne.setFirstKey() > splitTwo.setFirstKey())
                { 
                 addSpecificChild(splitTwo);
                 addSpecificChild(splitOne);
                } 
             else
                {
                 addSpecificChild(splitOne);
                 addSpecificChild(splitTwo);   
                } 
            } 
         while (keyList.size() != 1)
             {
              if (keyList.get(index) != midKey)
                 {
                  //System.out.println("removed");
                  keyList.remove(index);
                 }
              index ++;
             }
        } 
     else
        {
         System.out.println("Not Parent Split");
         //System.out.println(parent.toString());
         splitOne = new Node(false);
         sibling = splitOne;
         for (int i = 0; i < parent.children.size(); i ++)
             {
              oldChildren.add(parent.children.get(i));   
             }
         oldChildren.add(splitOne);
         while (parent.children.size() != 0)
               { 
                parent.children.remove(0);
               }
         //System.out.print("ParentKids: ");
         //System.out.println(parent.children.toString());
         for (int i = mid; i < n; i ++)
             {
              //System.out.println(parent.children.toString());
              sibling.setKey(keyList.get(i));
             }
         while(keyList.size() > mid)
             {
              //System.out.println("splitcheck");
              //System.out.println(keyList.get(keyList.size()-1));
              if (keyList.get(keyList.size()-1) >= midKey)
                 {     
                  keyList.remove(keyList.size()-1);
                 } 
             }
         //System.out.println("splitTestThing1");
         //System.out.println(oldChildren.size());
         int ind = oldChildren.size();
         for (int i = 0; i < ind; i ++)
             {
              sortList.add(oldChildren.get(i).setFirstKey());                 
              //System.out.println(oldChildren.get(i).setFirstKey());
              //System.out.println(i);
             }
         //System.out.println(sortList.toString());
         Collections.sort(sortList);
         //System.out.println("splitTestThing2");
         //System.out.println(oldChildren.size());
         //System.out.println(sortList.size()); 
         for (int i = 0; i < ind; i ++)
             {
              //System.out.print("i");
              //System.out.println(i);
              for (int q = 0; q < ind; q ++)
                  {
                   //System.out.print("q");
                   //System.out.println(q);
                   if (oldChildren.get(q).getFirstKey() == sortList.get(i))
                      {
                       //System.out.println(oldChildren.get(q).toString());
                       parent.children.add(oldChildren.get(q));
                      } 
                  }
             }
         while (oldChildren.size() != 0)
                 { 
                  oldChildren.remove(0);
                 }
         parent.setKey(midKey);
        } 
 }
 
 public String toString()
 {
     String result = "";
     for (int i = 0; i < keyList.size(); i ++)
         {
          result += keyList.get(i);
          result += ",";
         }
     return result;
 }       
}


