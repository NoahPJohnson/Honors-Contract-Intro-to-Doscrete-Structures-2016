/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package BplusTree;

/**
 *
 * @author Noah
 */

import java.util.ArrayList;
import java.util.Collections;

public class Node
{
 private int n = 3;
 private int firstKey;
 private ArrayList<Integer> keyList;
 private ArrayList<Integer> sortList;
 private ArrayList<Node> children;
 private ArrayList<Node> oldChildren;
 private Node leftSibling;
 private Node rightSibling;
 private Node parent;
 private Node splitOne;
 private Node splitTwo;
 
 private int childCount;
 private boolean root = false;

 public Node(boolean r)
 {
  keyList = new ArrayList();
  sortList = new ArrayList();
  children = new ArrayList();
  oldChildren = new ArrayList();  
  if (keyList.size() > 0)
     {
      firstKey = keyList.get(0);
     }
  childCount = 0;
  parent = null;
  leftSibling = null;
  rightSibling = null;
  root = r; 
 }        
 
 public int getN()
 {
    return n;
 } 
 
 public void setParent(Node p)
 {
    parent = p;
 }
 
 public Node getParent()
 {
    return parent; 
 }        
 
 public boolean checkIfRoot()
 {
    return root;
 }     
 
 public ArrayList getKeyList()
 {
    return keyList;   
 }
 
 public int getKey(int i)
 {
    return keyList.get(i);
 }        
 
 public ArrayList<Node> getChildren()
 {
    return children;   
 }        
 
 public int getChildCount()
 {
     return childCount;
 }  
 
 public Node getChild(int i)
 {
     return children.get(i);
 }        
         
 public void setKey(int e)
 {
    if (!keyList.contains(e))
       { 
        keyList.add(e);
       } 
    Collections.sort(keyList);
    if (keyList.size() >= n)
       {
        split();   
       } 
 }   
 
 public void remKey(int e)
 {
    keyList.remove(keyList.indexOf(e));
    if (keyList.size() < n/2)
       {
        if (leftSibling.getKeyList().size() < n/2)
           {
               
           }
        else
           {
               
           } 
       } 
 }        
 
 public void addChild()
 {
    childCount ++;
    children.add(new Node(false));
 }          
 
 public void addSpecificChild(Node c)
 {
     childCount ++;
     children.add(c);
 }        
 
 public int getFirstKey()
 {
     return firstKey;   
 }
 
 public int setFirstKey()
 {
  if (keyList.size() != 0)
     {
      firstKey = keyList.get(0);
     } 
  return firstKey;
 }    
 
 public void setLeftSibling(Node s)
 {
     leftSibling  = s;
 } 
 public void setRightSibling(Node s)
 {
     rightSibling = s;
 }        
 
 public boolean itemSearch(int key)
 {
    if (keyList.contains(key))
       {
        return true;
       }
    else
       {
        return false; 
       } 
 }       
         
 public void split()
 {
     int mid = n/2;
     int midKey = keyList.get((n/2));
     int index = 0; 
     if (checkIfRoot() == true)
        { 
         if (children.size() > 0)
            { 
             System.out.println("Root Secondary Split");
             for (int i = 0; i < children.size(); i ++)
                 {
                  oldChildren.add(children.get(i));   
                 } 
             while (children.size() != 0)
                 { 
                  children.remove(0);
                 }
             System.out.print("OldChildren: ");
             System.out.println(oldChildren.toString());
             //System.out.print("ChildrenEmpty: ");
             //System.out.println(children.toString());

             splitOne = new Node(false);
             for (int i = 0; i < mid; i ++)
                 {
                  splitOne.setKey(keyList.get(i));
                  if (oldChildren.size() > 0)
                     { 
                      for (int q = 0; q < oldChildren.size()/2; q ++)
                          {
                           splitOne.children.add(oldChildren.get(q));
                          }
                     }     
                 }
             System.out.print("Children1: ");
             System.out.println(splitOne.children.toString());

             splitTwo = new Node(false);
             for (int i = mid+1; i < n; i ++)
                 {
                  splitTwo.setKey(keyList.get(i));
                  if (oldChildren.size() > 0)
                     { 
                      for (int q = oldChildren.size()/2; q < oldChildren.size(); q ++)
                          {
                           splitTwo.children.add(oldChildren.get(q));
                          }
                     }      
                 }
             //children.get(children.size()-2).addSpecificChild(children.get(childCount-1));
             System.out.print("Children2: ");
             System.out.println(splitTwo.children.toString());
             
             if (splitOne.setFirstKey() > splitTwo.setFirstKey())
                { 
                 addSpecificChild(splitTwo);
                 addSpecificChild(splitOne);
                } 
             else
                {
                 addSpecificChild(splitOne);
                 addSpecificChild(splitTwo);   
                } 
             while (oldChildren.size() != 0)
                 { 
                  oldChildren.remove(0);
                 }
             while (keyList.size() != 1)
                {
                 if (keyList.get(index) != midKey)
                    {
                     //System.out.println("removed");
                     keyList.remove(index);
                    }
                 index ++;
                }
            }
        else 
            {
             System.out.println("Root Split");
             splitOne = new Node(false);
             for (int i = 0; i < mid; i ++)
                 {
                  splitOne.setKey(keyList.get(i));
                 }
             
             splitTwo = new Node(false);
             for (int i = mid; i < n; i ++)
                 {
                  splitTwo.setKey(keyList.get(i));
                 }
             //splitOne.setRightSibling(splitTwo);
             //splitTwo.setleftSibling(splitOne);
             if (splitOne.setFirstKey() > splitTwo.setFirstKey())
                { 
                 addSpecificChild(splitTwo);
                 addSpecificChild(splitOne);
                } 
             else
                {
                 addSpecificChild(splitOne);
                 addSpecificChild(splitTwo);   
                } 
             while (keyList.size() != 1)
                {
                 if (keyList.get(index) != midKey)
                    {
                     //System.out.println("removed");
                     keyList.remove(index);
                    }
                 index ++;
                }
            }
        }
    else
        {
         if (children.size() > 0)
            {
             System.out.println("Parent Secondary Split");
             for (int i = 0; i < children.size(); i ++)
                 {
                  oldChildren.add(children.get(i));   
                 } 
             
             while (children.size() != 0)
                 { 
                  children.remove(0);
                 }
             System.out.print("OldChildren: ");
             System.out.println(oldChildren.toString());
             //System.out.print("ChildrenEmpty: ");
             //System.out.println(children.toString());

             splitOne = new Node(false);
             for (int i = mid+1; i < n; i ++)
                 {
                  splitOne.setKey(keyList.get(i));
                  if (oldChildren.size() > 0)
                     { 
                      for (int q = oldChildren.size()/2; q < oldChildren.size(); q ++)
                          {
                           splitOne.children.add(oldChildren.get(q));
                          }
                     }      
                 }
             //children.get(children.size()-2).addSpecificChild(children.get(childCount-1));
             System.out.print("Children2: ");
             System.out.println(splitOne.children.toString());
             
             while(keyList.size() > mid)
                 {
                  //System.out.println("splitcheck");
                  //System.out.println(keyList.get(keyList.size()-1));
                  if (keyList.get(keyList.size()-1) >= midKey)
                     {     
                      keyList.remove(keyList.size()-1);
                     } 
                 }
             if (oldChildren.size() > 0)
                { 
                 for (int q = 0; q < oldChildren.size()/2; q ++)
                     {
                      this.children.add(oldChildren.get(q));
                     }   
                 }
             System.out.print("Children1: ");
             System.out.println(this.children.toString());
             
             splitOne.setParent(this.parent);
             
             parent.addSpecificChild(splitOne);
             
             while (oldChildren.size() != 0)
                 { 
                  oldChildren.remove(0);
                 }
             while (keyList.size() != 1)
                {
                 if (keyList.get(index) != midKey)
                    {
                     //System.out.println("removed");
                     keyList.remove(index);
                    }
                 index ++;
                }   
            }     
         else
            { 
             System.out.println("Not Parent Split");
             System.out.print("This node: ");
             System.out.println(this.toString());
             //System.out.println(parent.toString());
             splitOne = new Node(false);
             //rightSibling = splitOne;
             for (int i = 0; i < parent.children.size(); i ++)
                 {
                  oldChildren.add(parent.children.get(i));   
                 }
             oldChildren.add(splitOne);
             System.out.print("oldChildren: ");
             System.out.println(oldChildren.toString());
             while (parent.children.size() != 0)
                   { 
                    parent.children.remove(0);
                   }
             //System.out.print("ParentKids: ");
             //System.out.println(parent.children.toString());
             //rightSibling.setSibling(this);
             for (int i = mid; i < n; i ++)
                 {
                  //System.out.println(parent.children.toString());
                  splitOne.setKey(keyList.get(i));
                 }
             System.out.print("splitOne: ");
             System.out.println(splitOne.toString());
             while(keyList.size() > mid)
                 {
                  //System.out.println("splitcheck");
                  //System.out.println(keyList.get(keyList.size()-1));
                  if (keyList.get(keyList.size()-1) >= midKey)
                     {     
                      keyList.remove(keyList.size()-1);
                     } 
                 }
             System.out.print("keyList: ");
             System.out.println(keyList.toString());
             //System.out.println("splitTestThing1");
             //System.out.println(oldChildren.size());
             int ind = oldChildren.size();
             for (int i = 0; i < ind; i ++)
                 {
                  sortList.add(oldChildren.get(i).setFirstKey());                 
                  //System.out.println(oldChildren.get(i).setFirstKey());
                  //System.out.println(i);
                 }
             System.out.print("sortList: ");
             System.out.println(sortList.toString());
             Collections.sort(sortList);
             //System.out.println("splitTestThing2");
             //System.out.println(oldChildren.size());
             //System.out.println(sortList.size()); 
             for (int i = 0; i < ind; i ++)
                 {
                  //System.out.print("i");
                  //System.out.println(i);
                  for (int q = 0; q < ind; q ++)
                      {
                       //System.out.print("q");
                       //System.out.println(q);
                       if (oldChildren.get(q).getFirstKey() == sortList.get(i))
                          {
                           System.out.print("addThis: ");
                           System.out.println(oldChildren.get(q).toString());
                           parent.children.add(oldChildren.get(q));
                          } 
                      }
                 }
             System.out.print("NotParentSplit, Children: ");
             System.out.println(parent.children.toString());
             while (oldChildren.size() != 0)
                   { 
                    oldChildren.remove(0);
                   }
             while (sortList.size() != 0)
                   { 
                    sortList.remove(0);
                   }
             parent.setKey(midKey);
            }
        } 
 }
 
 public void merge()
 {
     
 }         
 
 public String toString()
 {
     String result = "";
     for (int i = 0; i < keyList.size(); i ++)
         {
          result += keyList.get(i);
          result += ",";
         }
     return result;
 }       
}


